#!/bin/bash
#
# swgemu - Control swgemu server on this machine
#
# Author: Lord Kator <lordkator@swgemu.com>
#
# Created: Sun Jan  3 13:30:33 UTC 2016
#

# TODO make these use global config
BUILD_DIR=~/workspace/Core3/MMOCoreORB
RUN_DIR=~/workspace/Core3/MMOCoreORB/bin

main() {
    get_lock

    local cmd=$1
    local ret=255

    shift

    case $cmd in
	'start' ) server_start ;;
	'status' ) server_status ;;
	'backup' ) server_backup ;;
	'build' ) server_build ;;
	'send' ) server_send $@ ;;
	'stop' ) server_stop;;
	* ) echo "Usage: $0 {start|stop|status|backup|build}"; exit 1 ;;
    esac

    ret=$?

    release_lock

    exit $ret
}

ICON=/home/vagrant/ZonamaDev/fasttrack/assets/swgemu_icon.png

server_start() {
    if server_status; then
	echo "** Already running **"
	if yorn "Would you like to stop the sever?"; then
	    server_stop
	else
	    release_lock
	    screen -D -RR swgemu-server
	fi
	exit 0
    fi

    server_update_ip

    cd "${RUN_DIR}"

    if [ ! -x core3 ]; then
	echo "** Server not built? **"

	if yorn "Would you like to build the server now?"; then
	    if server_build; then
		:
	    else
		exit $?
	    fi
	else
	    echo "** USER ABORTED **"
	    exit 2
	fi
    fi

    for i in 5 4 3 2 1
    do
	let "j=$i-1"
	mv o_screenlog.${j}.gz o_screenlog.${i}.gz 2> /dev/null
    done

    mv screenlog.0 o_screenlog.0

    gzip -f o_screenlog.0 &

    # Start server detached
    screen -dmS swgemu-server -L ./core3

    # Free lock
    release_lock

    # TODO Spawn a watcher to alert when the server is up
    ~/bin/sentinel --stop-at-init &

    # Join the session so they can watch along..
    exec screen -D -RR swgemu-server
}

server_status() {
    local pid=$(pgrep core3)
    local verbose=true

    if [ "X$1" = "X-q" ]; then
        verbose=false
    fi

    if [ -z "$pid" ]; then
	if $verbose; then
	    echo "Server is not running"
	fi
	return 1
    fi

    if $verbose; then
	read uptime <<< $(ps -p $pid -ho etime)

	echo "Server running on $pid, uptime: $uptime"
    fi

    return 0
}

server_send() {
    if server_status -q; then
	:
    else
	echo "** Server not running **"
	return 0
    fi

    local string="$*^M"

    local sz=$(stat -c '%s' screenlog.0)

    screen -S swgemu-server -X stuff "$string"

    ~/bin/sentinel --stop-next-prompt --tail --seek $sz

    return 1
}

server_stop() {
    if server_status -q; then
	:
    else
	echo "** Server not running **"
	exit 0
    fi

    cd "${RUN_DIR}"

    if [ ! -f "screenlog.0" ]; then
	echo "** screenlog is missing, did you run the server from $0?"
	exit 1
    fi

    local sz=$(stat -c '%s' screenlog.0)
    local pid=$(pgrep core3)

    echo "** send 'save' command to server **"

    screen -S swgemu-server -X stuff "save^M"

    # TODO add timeout?

    if ~/bin/sentinel --stop-next-backup --seek $sz; then
	echo "** server backup complete **"
	echo -n "** sending SIGINT.."
	kill -INT $pid
	while pgrep core3 > /dev/null 2>&1
	do
	    echo -n "."
	    sleep 1
	done
	echo -e "\n** server stopped **"
	exit 0
    else
	echo "** sentinel failed with err=$?"
    fi
}

server_build() {
    if server_status; then
	echo "** Server is running **"

	if yorn "Would you like to join the console so you can shut it down?"; then
	    screen -D -RR swgemu-server
	else
	    echo "** USER ABORTED BUILD **"
	    exit 12
	fi
    fi

    cd "${BUILD_DIR}"

    if [ ! -f build/unix/config.log ]; then
	if time make config; then
	    :
	else
	    echo "** make config failed **"
	    exit 10
	fi
    fi

    if time make -k build; then
	echo "** BUILD SUCCESS IN $SECONDS SECOND(S) **"
	exit 0
    else
	echo "** BUILD FAILED **"
	exit 11
    fi
}

server_update_ip() {
    local server_ip='127.0.0.1'

    if [ -f ~/.force_ip ]; then
	server_ip=$(cat ~/.force_ip)
    fi

    local i2=$(netstat -ni|grep eth2)

    # If they have an eth2 they might have enabled the "public" interface
    if [ -n "$i2" ]; then
	# Find the default route
	read -a aa <<<$(ip -o route show|egrep '^default')
	# What's the address of the interface with default route?
	read -a aa <<<$(ip -o -4 addr show ${aa[4]})
	# Let's suggest that ip
	server_ip=$(echo ${aa[3]}|cut -d/ -f1)
    fi

    echo "Suggested IP: $server_ip"

    eval $(~/bin/get_config --bash ZoneGalaxyID)

    mysql swgemu -ve "UPDATE galaxy SET address = '${server_ip}' WHERE galaxy_id = ${ZoneGalaxyID}";
    mysql swgemu -ve "UPDATE galaxy SET name = 'swgemudev' WHERE galaxy_id = ${ZoneGalaxyID} AND name = 'Core3'";
    sed -e "/server_ip/s/server_ip = '[^']*'/server_ip = '"${server_ip}"'/" -i /home/vagrant/server/emuyoda/yoda-config.lua
}

server_backup() {
    if server_status; then
	echo "** Server is running **"

	if yorn "Would you like to join the console so you can shut it down?"; then
	    screen -D -RR swgemu-server
	else
	    echo "** USER ABORTED BACKUP **"
	    exit 12
	fi
    fi

    # NOTE: not the most space efficent way to do it but will work as it's simple for people to understand the format

    BUDIR=~/server/swgemu/backups

    mkdir -p ${BUDIR} 2> /dev/null && echo "** Created ${BUDIR} directory **"

    TMPDIR=$(mktemp -d ${BUDIR}/swgemu-backup-temp.XXXXXX)

    (
	trap 'set +xe;st=$?;echo "** UNEXPECTED EXIT=$st, PARTIAL BACKUP LEFT IN ${TMPDIR} **";rm -f ${SWGEMU_LOCKFILE};exit $st' 0

	NOW=$(date +%s)

	STAMP=$(date -d@${NOW} '+%Y%m%d%H%M%S%Z')

	BUFILE=${BUDIR}/swgemu-backup-${STAMP}.tar.gz

	echo "** Backing up to ${BUFILE} **"

	set -xe

	mysqldump --opt swgemu > "${TMPDIR}/mysqldump.sql"

	cd "${RUN_DIR}"

	cp -rv conf databases ${TMPDIR}

	cd ${TMPDIR}

	files=$(echo *)

	read sz dir <<< $(du -s --block-size=1 .)

	# TODO - Other useful metadata here?
	echo '{"backup_size_bytes":"'${sz}'","backup_date":"'$(date -d@${NOW})'","backup_isodate":"'$(date -d@${NOW} -Iseconds)'","backup_unixepoc":"'${NOW}'"}' > ${TMPDIR}/metadata.json

	# TODO do we need the __db files if the db is closed?
	tar cvzf ${BUFILE} metadata.json $(find $files -type f|sort)

	rm -fr ${TMPDIR}

	set +xe

	trap - 0

	echo "** SUCCESS: Backup saved to ${BUFILE} **"
    )

    exit 0
}

yorn() {
  if tty -s; then
      echo -n -e "$@ Y\b" > /dev/tty
      read yorn < /dev/tty
      case $yorn in
	[Nn]* ) return 1;;
      esac
  fi

  return 0
}

release_lock() {
    if $HAVELOCK; then
	rm -f ${SWGEMU_LOCKFILE}
    fi
}

get_lock() {
    ## Run LOCK
    export HAVELOCK=false
    local locktmp=$(mktemp /tmp/swgemu.lock-XXXXXX)
    export SWGEMU_LOCKFILE=/tmp/swgemu.lock

    echo "$$ "$(date +%s) > ${locktmp}

    if ln ${locktmp} ${SWGEMU_LOCKFILE} 2> /dev/null; then
	rm -f ${locktmp}
	export HAVELOCK=true
    else
	read pid tm_lock < ${SWGEMU_LOCKFILE}
	tm_now=$(date +%s)

	let "tm_delta=${tm_now} - ${tm_lock}"

	if kill -0 $pid; then
	    echo ">> PID $pid HAS HAD LOCK FOR ${tm_delta} SECOND(S), EXITING"
	    exit 0
	else
	    echo ">> Stealing lock from PID $pid which has gone away, locked ${tm_delta} second(s) ago"
	    if ln -f ${locktmp} ${SWGEMU_LOCKFILE}; then
		rm -f ${locktmp}
		read pid tm_lock < ${SWGEMU_LOCKFILE}
		if [ "$pid" -eq "$$" ]; then
		    echo ">> STOLE LOCK, PROCEEDING"
		else
		    echo ">> Can't steal lock, somone got in before us!? pid=${pid}"
		    exit 2
		fi
	    else
		rm -f ${locktmp}
		echo ">> Failed to steal lock, **ABORT**"
		exit 1
	    fi
	fi
    fi

    export HAVELOCK=true
    trap 'release_lock;' 0
}

main $@

exit 0
